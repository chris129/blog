python manager.py shell里面的增删数据：
    写入数据：
    c = Category(name='category test')
    c.save()
    查找数据：
    c = Category.objects.get(name='category test')
    model里面增加一个__str__方法让其默认返回一个数据：
        def __str__(self):
            return self.name
    Category.objects.all()
    修改数据：
    c = Category.objects.get(name='category test')
    c.name = 'category test new'
    c.save()
    删除数据-先查出来删除即可：
     p = Post.objects.get(title='title test')
     p.delete()



template 里的模板：
    这里的 {% block main %}{% endblock main %} 是一个占位框，main 是我们给这个 block 取的名字。下面我们会看到 block 标签的作用。
    同时我们也在 aside 标签下加了一个 {% block toc %}{% endblock toc %} 占位框，因为 detail.html 中 aside 标签下会多一个目录栏。
    当 {% block toc %}{% endblock toc %} 中没有任何内容时，{% block toc %}{% endblock toc %} 在模板中不会显示。但当其中有内容是，
    模板就会显示 block 中的内容。

    新的index.html代码里面加入{% extends 'base.html' %}
    这样 base.html 里的代码加上 {% block main %}{% endblock main %} 里的代码就和最开始 index.html 里的代码一样了。这就是模板继承
    的作用，公共部分的代码放在 base.html 里，而其它页面不同的部分通过替换 {% block main %}{% endblock main %} 占位标签里的内容即可。
    如果你对这种模板继承还是有点糊涂，可以把这种继承和 Python 中类的继承类比。base.html 就是父类，index.html 就是子类。index.html
    继承了 base.html 中的全部内容，同时它自身还有一些内容，这些内容就通过 “覆写” {% block main %}{% endblock main %}（把 block
    看做是父类的属性）的内容添加即可。
    detail 页面处理起来就简单了，同样继承 base.html ，在 {% block main %}{% endblock main %} 里填充 detail.html 页面应该显示的
    内容，以及在 {% block toc %}{% endblock toc %} 中填写 base.html 中没有的目录部分的内容。不过目前的目录只是占位数据，我们在以后
    会实现如何从文章中自动摘取目录。


    <a href="{% url 'blog:archives' date.year date.month %}">
    这里 {% url %} 这个模板标签的作用是解析视图函数 blog:archives 对应的 URL 模式，并把 URL 模式中的年和月替换成 date.year，
    date.month 的值。例如 blog:archives 表示 blog 应用下的 archives 函数，这个函数对应的 URL 模式为
     ^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$，假设 date.year=2017，date.month=5，
     那么 {% url 'blog:archives' date.year date.month %} 模板标签返回的值为/archives/2017/5/。
    为什么要使用 {% url %} 模板标签呢？事实上，我们把超链接的 href 属性设置为 /archives/{{ date.year }}/{{ date.month }}/
    同样可以达到目的，但是这种写法是硬编码的。虽然现在 blog:archives 视图函数对应的 URL 模式是这种形式，但是如果哪天这个模式改变了呢？
    如果使用了硬编码的写法，那你需要把每一处 /archives/{{ date.year }}/{{ date.month }}/ 修改为新的模式。但如果使用了 {% url %}
    模板标签，则不用做任何修改。测试一下，点击侧边栏归档的日期，跳转到归档页面，发现报了个错误，提示没有安装 pytz。激活虚拟环境，使用 pip install pytz 安装即可。

markdown:pip install markdown
    将 Markdown 格式的文本渲染成 HTML 文本非常简单，只需调用这个库的 markdown 方法即可。我们书写的博客文章内容存在 Post 的 body 属性里
    # 一级标题
    ## 二级标题
    ### 三级标题
    - 列表项1
    - 列表项2
    - 列表项3
    > 这是一段引用
    ​```python     ----->code代码必须表示是Python还是java才能高亮
    def detail(request, pk):
        post = get_object_or_404(Post, pk=pk)
        post.body = markdown.markdown(post.body,
                                      extensions=[
                                          'markdown.extensions.extra',
                                          'markdown.extensions.codehilite',
                                          'markdown.extensions.toc',
                                      ])
        return render(request, 'blog/detail.html', context={'post': post})
    ​```

markdown的代码高亮：pip install Pygments
