python manager.py shell里面的增删数据：
    写入数据：
    c = Category(name='category test')
    c.save()
    查找数据：
    c = Category.objects.get(name='category test')
    model里面增加一个__str__方法让其默认返回一个数据：
        def __str__(self):
            return self.name
    Category.objects.all()
    修改数据：
    c = Category.objects.get(name='category test')
    c.name = 'category test new'
    c.save()
    删除数据-先查出来删除即可：
     p = Post.objects.get(title='title test')
     p.delete()



template 里的模板：
    这里的 {% block main %}{% endblock main %} 是一个占位框，main 是我们给这个 block 取的名字。下面我们会看到 block 标签的作用。
    同时我们也在 aside 标签下加了一个 {% block toc %}{% endblock toc %} 占位框，因为 detail.html 中 aside 标签下会多一个目录栏。
    当 {% block toc %}{% endblock toc %} 中没有任何内容时，{% block toc %}{% endblock toc %} 在模板中不会显示。但当其中有内容是，
    模板就会显示 block 中的内容。

    新的index.html代码里面加入{% extends 'base.html' %}
    这样 base.html 里的代码加上 {% block main %}{% endblock main %} 里的代码就和最开始 index.html 里的代码一样了。这就是模板继承
    的作用，公共部分的代码放在 base.html 里，而其它页面不同的部分通过替换 {% block main %}{% endblock main %} 占位标签里的内容即可。
    如果你对这种模板继承还是有点糊涂，可以把这种继承和 Python 中类的继承类比。base.html 就是父类，index.html 就是子类。index.html
    继承了 base.html 中的全部内容，同时它自身还有一些内容，这些内容就通过 “覆写” {% block main %}{% endblock main %}（把 block
    看做是父类的属性）的内容添加即可。
    detail 页面处理起来就简单了，同样继承 base.html ，在 {% block main %}{% endblock main %} 里填充 detail.html 页面应该显示的
    内容，以及在 {% block toc %}{% endblock toc %} 中填写 base.html 中没有的目录部分的内容。不过目前的目录只是占位数据，我们在以后
    会实现如何从文章中自动摘取目录。


    <a href="{% url 'blog:archives' date.year date.month %}">
    这里 {% url %} 这个模板标签的作用是解析视图函数 blog:archives 对应的 URL 模式，并把 URL 模式中的年和月替换成 date.year，
    date.month 的值。例如 blog:archives 表示 blog 应用下的 archives 函数，这个函数对应的 URL 模式为
     ^archives/(?P<year>[0-9]{4})/(?P<month>[0-9]{1,2})/$，假设 date.year=2017，date.month=5，
     那么 {% url 'blog:archives' date.year date.month %} 模板标签返回的值为/archives/2017/5/。
    为什么要使用 {% url %} 模板标签呢？事实上，我们把超链接的 href 属性设置为 /archives/{{ date.year }}/{{ date.month }}/
    同样可以达到目的，但是这种写法是硬编码的。虽然现在 blog:archives 视图函数对应的 URL 模式是这种形式，但是如果哪天这个模式改变了呢？
    如果使用了硬编码的写法，那你需要把每一处 /archives/{{ date.year }}/{{ date.month }}/ 修改为新的模式。但如果使用了 {% url %}
    模板标签，则不用做任何修改。测试一下，点击侧边栏归档的日期，跳转到归档页面，发现报了个错误，提示没有安装 pytz。激活虚拟环境，使用 pip install pytz 安装即可。

markdown:pip install markdown
    将 Markdown 格式的文本渲染成 HTML 文本非常简单，只需调用这个库的 markdown 方法即可。我们书写的博客文章内容存在 Post 的 body 属性里
    # 一级标题
    ## 二级标题
    ### 三级标题
    - 列表项1
    - 列表项2
    - 列表项3
    > 这是一段引用
    ​```python     ----->code代码必须表示是Python还是java才能高亮
    def detail(request, pk):
        post = get_object_or_404(Post, pk=pk)
        post.body = markdown.markdown(post.body,
                                      extensions=[
                                          'markdown.extensions.extra',
                                          'markdown.extensions.codehilite',
                                          'markdown.extensions.toc',
                                      ])
        return render(request, 'blog/detail.html', context={'post': post})
    ​```

markdown的代码高亮：pip install Pygments




部署服务相关：
    标准目录结构:
        接下来需要把代码上传到服务器了。我服务器上存放代码的目录结构一般是这样的：
            /home/chris/
                sites/
                    demo.coolinux.cn/
                        env/
                        django-blog-tutorial/
        一台服务器可能部署多个网站，所有网站代码都放在 sites/ 目录下。demo.coolinux.cn/ 这个文件夹以网站的域名命名，便于区分。
        env/ 是 python 虚拟环境目录。django-blog-tutorial/ 是 Django 博客项目目录


        收集静态文件:
            虚拟环境下继续运行 python manage.py collectstatic 命令收集静态文件到 static 目录下
        生成数据库：
            继续运行 python manage.py migrate 命令创建数据库文件
        创建超级用户：
            python manage.py createsuperuser 命令创建一个超级用户，方便我们进入 Django 管理后台

        nginx配置：
            server {
            charset utf-8;
            listen 80;
            server_name demo.coolinux.cn; ①

            location /static { ②
                alias /home/chris/sites/demo.zmrenwu.com/django-blog-tutorial/static;
            }

            location / { ③
                proxy_set_header Host $host;
                #proxy_pass 后面使用了 unix 套接字，其作用是防止端口冲突
                proxy_pass http://unix:/tmp/demo.chris.cn.socket;
            }
        }

        使用Gunicorn管理进程：
            Gunicorn 一般用来管理多个进程，有进程挂了Gunicorn 可以把它拉起来，防止服务器长时间停止服务，还可以动态调整 worker 的数量，
            请求多的时候增加 worker 的数量，请求少的时候减少

            启动进程：
                安装pip install gunicorn
                (env) chris@localhost:~/sites/demo.coolunix.cn/django-blog-tutorial$ pip install gunicorn
                chris@...blog-tutorial$ gunicorn --bind unix:/tmp/demo.chris.cn.socket blogproject.wsgi:application

        CND加速：项目使用了 Bootstrap 和 jQuery，这两个文件我们是从本地加载的。如果服务器性能比较差的话，加载需要耗费很长的时间，
            网站打开的速度就变得无法忍受。我们使用 CDN 来加快加载速度

            base.html：修改本地的css和js为cdn节点的文件即可
            - <link rel="stylesheet" href="{% static 'blog/css/bootstrap.min.css' %}">
            - <script src="{% static 'blog/js/jquery-2.1.3.min.js' %}"></script>
            - <script src="{% static 'blog/js/bootstrap.min.js' %}"></script>
            + <link href="https://cdn.bootcss.com/bootstrap/3.3.7/css/bootstrap.min.css" rel="stylesheet">
            + <script src="https://cdn.bootcss.com/jquery/2.1.3/jquery.min.js"></script>
            + <script src="https://cdn.bootcss.com/bootstrap/3.3.7/js/bootstrap.min.js"></script>

使用febfic脚本自动化部署：
    部署步骤：
        远程连接服务器。
        进入项目根目录，从远程仓库拉取最新的代码。
        如果项目引入了新的依赖，需要执行 pip install -r requirement.txt 安装最新依赖。
        如果修改或新增了项目静态文件，需要执行 python manage.py collectstatic 收集静态文件。
        如果数据库发生了变化，需要执行 python manage.py migrate 迁移数据库。
        重启 Nginx 和 Gunicorn 使改动生效。

    代码如下：
        blogproject/fabfile.py

        from fabric.api import env, run
        from fabric.operations import sudo

        GIT_REPO = "you git repository" ①

        env.user = 'you host username' ②
        env.password = 'you host password'

        # 填写你自己的主机对应的域名
        env.hosts = ['demo.zmrenwu.com']

        # 一般情况下为 22 端口，如果非 22 端口请查看你的主机服务提供商提供的信息
        env.port = '22'


        def deploy():
            source_folder = '/home/yangxg/sites/zmrenwu.com/django-blog-tutorial' ③

            run('cd %s && git pull' % source_folder) ④
            run("""
                cd {} &&
                ../env/bin/pip install -r requirements.txt &&
                ../env/bin/python3 manage.py collectstatic --noinput &&
                ../env/bin/python3 manage.py migrate
                """.format(source_folder)) ⑤
            sudo('restart gunicorn-demo.zmrenwu.com') ⑥
            sudo('service nginx reload')
        说明：
            ① 你的代码托管仓库地址。
            ② 配置一些服务器的地址信息和账户信息，各参数的含义分别为：
            env.user：用于登录服务器的用户名
            env.password：用户名对应的密码
            env.hosts：服务器的 IP 地址，也可以是解析到这个 IP 的域名
            env.port：SSH 远程服务器的端口号
            ③ 需要部署的项目根目录在服务器上的位置。
            ④ 通过 run 方法在服务器上执行命令，传入的参数为需要执行的命令，用字符串包裹。这里执行了两条命令，不同命令间用 && 符号连接：
            cd 命令进入到需要部署的项目根目录
            git pull 拉取远程仓库的最新代码
            ⑤ 对应上述部署过程中 3-5 的几条命令。因为启用了虚拟环境，所以运行的是虚拟环境 ../env/bin/ 下的 pip 和 python
            ⑥ 重启 Gunicorn 和 Nginx，由于这两条命令要在超级权限下运行，所以使用了 sudo 方法而不是 run 方法。
        本地执行：
            fab deploy

分页：
    当博客上发布的文章越来越多时，通常需要进行分页显示，以免所有的文章都堆积在一个页面，影响用户体验。Django 内置的 Pagination
    能够帮助我们实现简单的分页功能
    from django.core.paginator import Paginator
    对 item_list 进行分页，每页包含 2 个数据
    item_list = ['john', 'paul', 'george', 'ringo']
    p = Paginator(item_list, 2)
    取特定页的数据：
    # 取第 2 页的数据
    >>> page2 = p.page(2)
    >>> page2.object_list
    查询特定页的当前页码数：
    >>> page2.number
    查看分页后的总页数：
    >>> p.num_pages
    查看某一页是否还有上一页，以及查询该页上一页的页码：
    # 查询第二页是否还有上一页
    >>> page2.has_previous()
    True
    # 查询第二页上一页的页码
    >>> page2.previous_page_number()
    1
    查看某一页是否还有下一页，以及查询该页下一页的页码：
    # 查询第二页是否还有下一页
    >>> page2.has_next()
    False
    # 查询第二页下一页的页码
    >>> page2.next_page_number()
    django.core.paginator.EmptyPage: That page contains no results

    另外一种分页方式：类视图
    视图函数转换成了类视图。而类视图 ListView 已经帮我们写好了上述的分页逻辑，我们只需通过指定 paginate_by 属性来开启分页功能即可，
    即在类视图中指定 paginate_by 属性的值

    django官方例子：
        from django.core.paginator import Paginator, EmptyPage, PageNotAnInteger
        from django.shortcuts import render

        def listing(request):
            contact_list = Contacts.objects.all()
            paginator = Paginator(contact_list, 25) # 每页显示 25 个联系人

            page = request.GET.get('page')
            try:
                contacts = paginator.page(page)
            except PageNotAnInteger:
                # 如果用户请求的页码号不是整数，显示第一页
                contacts = paginator.page(1)
            except EmptyPage:
                # 如果用户请求的页码号超过了最大页码号，显示最后一页
                contacts = paginator.page(paginator.num_pages)

            return render(request, 'list.html', {'contacts': contacts})



